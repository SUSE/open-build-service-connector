/**
 * Copyright (c) 2021 SUSE LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import { Commit } from "open-build-service-api";

/** Message types that the history graph webview will react to */
export const enum MessageType {
  /** The retrieval of the history of a package has been started */
  StartFetch = "start_fetch",
  /** The history has been fetched */
  HistoryReceived = "history_received"
}

/** A message indicating that the history of a new package is being fetched */
export interface StartFetchingHistoryMsg {
  type: MessageType.StartFetch;
  /** The name of the project to which the package belongs */
  projectName: string;
  /** The name of the package */
  name: string;
}

/**
 * A message containing the retrieved history.
 *
 * The actual commits are stored in a hash table where each commit can be found
 * via its key as generated by [[getCommitKey]]. Since we cannot send a hash
 * table over the wire, we dump its entries into an array of tuples and send it
 * as [[commitMapInitializer]].
 * The "start" of the history is recorded in the [[parentlessCommits]] field: it
 * contains all commits, that don't have a preceding commit (= parent commit).
 *
 * @tparam T
 */
export interface HistoryReceivedMsg<
  T extends JsonDumpedCommitWithChildren | CommitWithChildren
> {
  readonly type: MessageType.HistoryReceived;

  /**
   * Array of tuples consisting of a key and a json dumped
   * [[CommitWithChildren]] that can be used to construct a hash table
   * `key => commit`.
   */
  readonly commitMapInitializer: readonly (readonly [string, T])[];

  /**
   * Array of commits that have no parents (i.e. they are the first commit in a
   * branch=project+package combination).
   */
  readonly parentlessCommits: T[];
}

export type SendHistoryReceivedMsg = HistoryReceivedMsg<CommitWithChildren>;
export type ReceivedHistoryReceivedMsg = HistoryReceivedMsg<JsonDumpedCommitWithChildren>;

/**
 * A commit which `parentCommits` attribute does not contain another Commit
 * object, but only the commit's key (created by [[getCommitKey]]). This makes
 * it easier to send it to the webview as it needs to be serialized to JSON.
 */
export interface CommitWithHashes extends Omit<Commit, "parentCommits"> {
  /**
   * The keys of the parent commits.
   * The values are generated via [[getCommitKey]].
   */
  readonly parentCommits: string[];
}

/**
 * A commit which also contains the commits that come after it (called its child
 * commits).
 */
export interface CommitWithChildren extends CommitWithHashes {
  /**
   * The keys of child commits.
   * The values are generated via [[getCommitKey]].
   */
  readonly childCommits: string[];
}

/** Resulting type of JSON serializing a [[CommitWithChildren]] */
export interface JsonDumpedCommitWithChildren
  extends Omit<CommitWithChildren, "commitTime"> {
  readonly commitTime: string;
}

/**
 * Converts a JSON serialized [[CommitWithChildren]] into a
 * [[CommitWithChildren]].
 */
export function commitWithChildrenFromJson(
  commit: JsonDumpedCommitWithChildren
): CommitWithChildren {
  const { commitTime, ...rest } = commit;
  return { ...rest, commitTime: new Date(commitTime) };
}

/** Type guard for the [[CommitWithChildren]] type */
export function isCommitWithChildren(
  commit: Commit | CommitWithHashes | CommitWithChildren
): commit is CommitWithChildren {
  return Array.isArray((commit as CommitWithChildren).childCommits); // && ((arr.length > 0) ^ (typeof arr[0] === "string"));
}

/** Type guard for the [[CommitWithHashes]] type */
export function isCommitWithHashes(
  commit: Commit | CommitWithHashes | CommitWithChildren
): commit is CommitWithHashes {
  if (isCommitWithChildren(commit)) {
    return false;
  }
  return (
    commit.parentCommits !== undefined &&
    typeof commit.parentCommits[0] === "string"
  );
}

/**
 * Converts a [[Commit]] into a [[CommitWithHashes]] and leaves a
 * [[CommitWithHashes]] and [[CommitWithChildren]] untouched.
 */
export function commitToCommitWithHashes(
  commit: Commit | CommitWithHashes | CommitWithChildren
): CommitWithHashes | CommitWithChildren {
  if (isCommitWithHashes(commit) || isCommitWithChildren(commit)) {
    return commit;
  }
  const { parentCommits, ...rest } = commit;
  if (parentCommits === undefined) {
    return { ...rest, parentCommits: [] };
  } else {
    return {
      ...rest,
      parentCommits: parentCommits.map((c) => getCommitKey(c))
    };
  }
}

/**
 * Generates a unique key for a commit to retrieve it from a hash table.
 *
 * Note that we cannot use the revisionHash only, because it can be the same
 * value across branches.
 */
export const getCommitKey = (
  commit: Commit | CommitWithHashes | CommitWithChildren
): string =>
  `${commit.projectName}/${commit.packageName}@${commit.revisionHash}`;

/**
 * Returns a "branch" name for a package on OBS.
 * The branch name is used for displaying the log
 */
export const getBranchName = (
  commit: Commit | CommitWithHashes | CommitWithChildren
): string => `${commit.projectName}/${commit.packageName}`;

/**
 * Converts a commit key generated by [[getCommitKey]] to a branch name as it
 * would be generated by [[getBranchName]].
 */
export const commitKeyToBranchName = (commitKey: string): string =>
  commitKey.split("@")[0];
